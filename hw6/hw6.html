<!DOCTYPE html>ntListener('DOMContentLoaded', () => {
<html lang="en">nimation();
<head>itSpiValueAnimation();
    <meta charset="UTF-8">n();
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ECE362 HW6 Study Animations</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Open+Sans:wght@400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <script src="../animation-utils.js"></script>
    <script src="script.js"></script>
</head>tI2cAddressAnimation();
<body>nst animateBtn = document.getElementById('sine-wave-animate-btn');dy>
    animateBtn?.addEventListener('click', initSineWaveAnimation);    <div class="navbar">
});</a>
>HW2</a>
// Initialize each animation section
function initSpiWordAnimation() {
    // Corrected ID to target spi-word-mosi5.html">HW5</a>
    const signalBitsMOSI = document.getElementById('spi-word-mosi');
    if (!signalBitsMOSI) {
        console.error("Element with ID 'spi-word-mosi' not found!"); // Error logging for debuggingh1>ECE362 HW6 Study Animations</h1>
        return;    <div class="content">
    }
        <div class="section" id="spi-word-section">
    signalBitsMOSI.innerHTML = Array(15).fill('<span class="bit low">0</span>').join('');

    const animateBtn = document.getElementById('spi-word-animate-btn');
    const stepsBtn = document.getElementById('spi-word-steps-btn');pi-word-size" min="8" max="32" value="15"></label>
    const resetBtn = document.getElementById('spi-word-reset-btn');            </div>
    const steps = document.getElementById('spi-word-steps');
oltip="Serial Peripheral Interface: A synchronous protocol using clock (SCK) and data (MOSI) lines.">SPI</span> signal below, find the <strong>word size</strong> in bits, read on <strong>rising edges</strong> of SCK. The signal has <strong>15 rising edges</strong>, indicating <strong>15 bits</strong>.
    animateBtn?.addEventListener('click', () => {
        // Pass the correct container to animateSpiWordstyle="min-height: 300px;">
        const containers = [signalBitsMOSI];         <div class="signal-row">
        animateSpiWord(containers, steps);                    <span class="signal-label">NSS</span>
    });

    stepsBtn?.addEventListener('click', () => toggleSteps(steps, stepsBtn));               <div class="signal-row">
    resetBtn?.addEventListener('click', () => resetAnimation(containers, steps, stepsBtn));                    <span class="signal-label">SCK</span>
}gnal-bits" id="spi-word-sck"></div>

function initSpiValueAnimation() {signal-row">
    const signalBits = document.getElementById('spi-value-mosi');                    <span class="signal-label">MOSI</span>
    if (!signalBits) return;
            </div>
    signalBits.innerHTML = Array(15).fill('<span class="bit low">0</span>').join('');
    
    const animateBtn = document.getElementById('spi-value-animate-btn');
    const stepsBtn = document.getElementById('spi-value-steps-btn');
    const resetBtn = document.getElementById('spi-value-reset-btn');            </div>
    const steps = document.getElementById('spi-value-steps');
mate-btn">Animate</button>
    animateBtn?.addEventListener('click', () => {btn">Show Steps</button>
        const containers = [signalBits];         <button id="spi-word-reset-btn">Reset</button>
        animateSpiValue(containers, steps);            </div>
    });

    stepsBtn?.addEventListener('click', () => toggleSteps(steps, stepsBtn));       <!-- Problem 2 -->
    resetBtn?.addEventListener('click', () => resetAnimation([signalBits], steps, stepsBtn));        <div class="section" id="spi-value-section">
}mitted Value</h2>

function initUartEncodeAnimation() { SPI signal (<strong>110001000010110</strong>), find the <strong>value transmitted</strong> (LSB first). The animation flips it to <strong>0x3423</strong>.
    const signalBits = document.getElementById('uart-encode-signal');            </div>
    if (!signalBits) return;
            <div class="signal-row">
    signalBits.innerHTML = Array(10).fill('<span class="bit low">0</span>').join('');
    >
    const animateBtn = document.getElementById('uart-encode-animate-btn');
    const stepsBtn = document.getElementById('uart-encode-steps-btn');
    const resetBtn = document.getElementById('uart-encode-reset-btn');            <div class="calculation-steps" id="spi-value-steps">
    const steps = document.getElementById('uart-encode-steps');
1010000010011</p>
    animateBtn?.addEventListener('click', () => {
        const containers = [signalBits];     </div>
        animateUartEncode(containers, steps);            <div class="controls">
    });

    stepsBtn?.addEventListener('click', () => toggleSteps(steps, stepsBtn));               <button id="spi-value-reset-btn">Reset</button>
    resetBtn?.addEventListener('click', () => resetAnimation([signalBits], steps, stepsBtn));            </div>
}

function initUartWordAnimation() {
    const signalBits = document.getElementById('uart-word-signal');        <div class="section" id="uart-encode-section">
    if (!signalBits) return;
        <!-- NEW: Add UART interactive control -->
    signalBits.innerHTML = Array(10).fill('<span class="bit low">0</span>').join('');
    -input-byte" value="53"></label>
    const animateBtn = document.getElementById('uart-word-animate-btn');
    const stepsBtn = document.getElementById('uart-word-steps-btn');
    const resetBtn = document.getElementById('uart-word-reset-btn');                Encode <strong>0x53</strong> for <span class="tooltip" data-tooltip="Universal Asynchronous Receiver/Transmitter: Sends data serially with start/stop bits.">UART</span> with 1 start bit, 8-bit word, no parity, 1 stop bit. The animation shows <strong>0110010101</strong>.
    const steps = document.getElementById('uart-word-steps');
">
    animateBtn?.addEventListener('click', () => {
        const containers = [signalBits];             <span class="signal-label">UART</span>
        animateUartWord(containers, steps);                    <div class="signal-bits" id="uart-encode-signal"></div>
    });

    stepsBtn?.addEventListener('click', () => toggleSteps(steps, stepsBtn));           <div class="calculation-steps" id="uart-encode-steps">
    resetBtn?.addEventListener('click', () => resetAnimation([signalBits], steps, stepsBtn));                <p>Start Bit: 0</p>
}ipped): 11001010</p>

function initParityAnimation() {al: 0110010101</p>
    const signalBits = document.getElementById('parity-data');            </div>
    if (!signalBits) return;
            <button id="uart-encode-animate-btn">Animate</button>
    signalBits.innerHTML = Array(9).fill('<span class="bit low">0</span>').join('');>
    
    const animateBtn = document.getElementById('parity-animate-btn');
    const stepsBtn = document.getElementById('parity-steps-btn');
    const resetBtn = document.getElementById('parity-reset-btn');
    const steps = document.getElementById('parity-steps');
rd-section">
    animateBtn?.addEventListener('click', () => {ord</h2>
        const containers = [signalBits];     <div class="description">
        animateParity(containers, steps);                Decode an ASCII word from a UART signal (7-bit word, 1 parity, 1 stop). The animation shows the first frame (<strong>0100100110</strong>) for 'd', with steps for all ("desk").
    });

    stepsBtn?.addEventListener('click', () => toggleSteps(steps, stepsBtn));               <div class="signal-row">
    resetBtn?.addEventListener('click', () => resetAnimation([signalBits], steps, stepsBtn));                    <span class="signal-label">UART</span>
}gnal-bits" id="uart-word-signal"></div>

function initBaudRateAnimation() {
    const signalBits = document.getElementById('baud-rate-signal');            <div class="calculation-steps" id="uart-word-steps">
    if (!signalBits) return;
            <p>Second: 0100110110 → 1010011 → 1100101 (0x65 = 'e')</p>
    signalBits.innerHTML = Array(10).fill('<span class="bit low">0</span>').join('');>
    ')</p>
    const animateBtn = document.getElementById('baud-rate-animate-btn');
    const stepsBtn = document.getElementById('baud-rate-steps-btn');
    const resetBtn = document.getElementById('baud-rate-reset-btn');            <div class="controls">
    const steps = document.getElementById('baud-rate-steps');">Animate</button>
eps-btn">Show Steps</button>
    animateBtn?.addEventListener('click', () => {-btn">Reset</button>
        const containers = [signalBits];     </div>
        animateBaudRate(containers, steps);        </div>
    });

    stepsBtn?.addEventListener('click', () => toggleSteps(steps, stepsBtn));       <div class="section" id="parity-section">
    resetBtn?.addEventListener('click', () => resetAnimation([signalBits], steps, stepsBtn));            <h2>Problem 5: Odd Parity Meaning</h2>
}">
nimation shows a frame where the total number of 1s (data + parity) is odd, confirming option c.
function initI2cConfigAnimation() {
    const signalBits = document.getElementById('i2c-config-sda');            <div class="signal-container">
    if (!signalBits) return;
                <span class="signal-label">Data</span>
    signalBits.innerHTML = '<div class="i2c-config"></div>';
    
    const animateBtn = document.getElementById('i2c-config-animate-btn');
    const stepsBtn = document.getElementById('i2c-config-steps-btn');
    const resetBtn = document.getElementById('i2c-config-reset-btn');                <p>Data: 10101010 (4 ones)</p>
    const steps = document.getElementById('i2c-config-steps');

    animateBtn?.addEventListener('click', () => {
        const containers = [signalBits];     <div class="controls">
        animateI2cConfig(containers, steps);                <button id="parity-animate-btn">Animate</button>
    });

    stepsBtn?.addEventListener('click', () => toggleSteps(steps, stepsBtn));           </div>
    resetBtn?.addEventListener('click', () => resetAnimation([signalBits], steps, stepsBtn));        </div>
}

function initI2cAckAnimation() {
    const ackSignal = document.getElementById('i2c-ack-signal');d</h2>
    const nackSignal = document.getElementById('i2c-nack-signal');            <div class="description">
    if (!ackSignal || !nackSignal) return;th 1 start, 8 data, 1 stop bit. The animation simulates a frame, showing <strong>1354 words/s</strong>.

    ackSignal.innerHTML = Array(5).fill('<span class="bit low">0</span>').join('');        <div class="signal-container">
    nackSignal.innerHTML = Array(5).fill('<span class="bit low">0</span>').join('');
    
    const animateBtn = document.getElementById('i2c-ack-animate-btn');></div>
    const stepsBtn = document.getElementById('i2c-ack-steps-btn');
    const resetBtn = document.getElementById('i2c-ack-reset-btn');            </div>
    const steps = document.getElementById('i2c-ack-steps');ud-words-steps">

    animateBtn?.addEventListener('click', () => {
        const containers = [ackSignal, nackSignal];         <p>Words/s: 13540 / 10 = 1354</p>
        animateI2cAck(containers, steps);            </div>
    });

    stepsBtn?.addEventListener('click', () => toggleSteps(steps, stepsBtn));               <button id="baud-words-steps-btn">Show Steps</button>
    resetBtn?.addEventListener('click', () => resetAnimation([ackSignal, nackSignal], steps, stepsBtn));                <button id="baud-words-reset-btn">Reset</button>
}

function initParityErrorAnimation() {
    const signalBits = document.getElementById('parity-error-signal');        <!-- Problem 7 -->
    if (!signalBits) return;
        <h2>Problem 7: UART Baud Rate</h2>
    signalBits.innerHTML = Array(10).fill('<span class="bit low">0</span>').join('');
    ere 10 bits take 50 ms. The animation shows signal changes, yielding <strong>200 baud</strong>.
    const animateBtn = document.getElementById('parity-error-animate-btn');
    const stepsBtn = document.getElementById('parity-error-steps-btn');
    const resetBtn = document.getElementById('parity-error-reset-btn');                <div class="signal-row">
    const steps = document.getElementById('parity-error-steps');RT</span>
its" id="baud-rate-signal"></div>
    animateBtn?.addEventListener('click', () => {
        const containers = [signalBits];     </div>
        animateParityError(containers, steps);            <div class="calculation-steps" id="baud-rate-steps">
    });

    stepsBtn?.addEventListener('click', () => toggleSteps(steps, stepsBtn));           </div>
    resetBtn?.addEventListener('click', () => resetAnimation([signalBits], steps, stepsBtn));            <div class="controls">
}e-animate-btn">Animate</button>
n>
function initI2cAddressAnimation() {baud-rate-reset-btn">Reset</button>
    const signalBits = document.getElementById('i2c-address-sda');            </div>
    if (!signalBits) return;

    signalBits.innerHTML = Array(8).fill('<span class="bit low">0</span>').join('');
    
    const animateBtn = document.getElementById('i2c-address-animate-btn');
    const stepsBtn = document.getElementById('i2c-address-steps-btn');
    const resetBtn = document.getElementById('i2c-address-reset-btn');                Identify a <strong>parity error</strong> in a UART frame. The animation shows a frame with even parity when odd parity is expected.
    const steps = document.getElementById('i2c-address-steps');
">
    animateBtn?.addEventListener('click', () => {
        const containers = [signalBits];             <span class="signal-label">UART</span>
        animateI2cAddress(containers, steps);                    <div class="signal-bits" id="parity-error-signal"></div>
    });

    stepsBtn?.addEventListener('click', () => toggleSteps(steps, stepsBtn));           <div class="calculation-steps" id="parity-error-steps">
    resetBtn?.addEventListener('click', () => resetAnimation([signalBits], steps, stepsBtn));                <p>Data: 10101010 (4 ones)</p>
}
/p>
function animateSpiWord(containers, steps) {ty (total should be odd)</p>
    resetAnimation(containers, steps);or</p>
    const signalBits = containers[0];            </div>
    const signal = '110001000010110';
="parity-error-animate-btn">Animate</button>
    signal.split('').forEach((bit, i) => {eps</button>
        setTimeout(() => {
            signalBits.children[i].classList.add('active');
            signalBits.children[i].classList.toggle('high', bit === '1');
            signalBits.children[i].classList.toggle('low', bit === '0');
            signalBits.children[i].textContent = bit; <!-- Problem 9 -->
        }, i * 300);        <div class="section" id="i2c-address-section">
    });
           <div class="description">
    setTimeout(() => highlightSteps(steps), signal.length * 300 + 500);                Find the <strong>I2C address</strong> from a signal. The animation shows the address bits, yielding <strong>0x3A</strong>.
}
er">
function animateSpiValue(containers, steps) {w">
    resetAnimation(containers, steps);al-label">SDA</span>
    const signalBits = containers[0];                    <div class="signal-bits" id="i2c-address-sda"></div>
    const signal = '110001000010110';

    signal.split('').forEach((bit, i) => {steps">
        setTimeout(() => {
            signalBits.children[i].classList.add('active');
            signalBits.children[i].classList.toggle('high', bit === '1');
            signalBits.children[i].classList.toggle('low', bit === '0');
            signalBits.children[i].textContent = bit;     <div class="controls">
        }, i * 300);                <button id="i2c-address-animate-btn">Animate</button>
    });
               <button id="i2c-address-reset-btn">Reset</button>
    setTimeout(() => highlightSteps(steps), signal.length * 300 + 500);            </div>
}

function animateUartEncode(containers, steps) {
    resetAnimation(containers, steps);
    const signalBits = containers[0];            <h2>Problem 10: I2C ACK/NACK</h2>
    const signal = '0110010101'; // Start bit (0) + Data (11001010) + Stop bit (1)control -->
teractive-controls" id="i2c-controls">
    signal.split('').forEach((bit, i) => {mmunication Error</button>
        setTimeout(() => {
            signalBits.children[i].classList.add('active');
            signalBits.children[i].classList.toggle('high', bit === '1');I2C. The animation shows both signals, with ACK being a low bit and NACK being a high bit.
            signalBits.children[i].classList.toggle('low', bit === '0');
            signalBits.children[i].textContent = bit;     <div class="signal-container">
        }, i * 300);                <div class="signal-row">
    });
                   <div class="signal-bits" id="i2c-ack-signal"></div>
    setTimeout(() => highlightSteps(steps), signal.length * 300 + 500);                </div>
}
l-label">NACK</span>
function animateUartWord(containers, steps) {l-bits" id="i2c-nack-signal"></div>
    resetAnimation(containers, steps);
    const signalBits = containers[0];            </div>
    const signal = '0100100110'; // First frame for 'd' id="i2c-ack-steps">
A pulled low</p>
    signal.split('').forEach((bit, i) => {
        setTimeout(() => {
            signalBits.children[i].classList.add('active');
            signalBits.children[i].classList.toggle('high', bit === '1');ate</button>
            signalBits.children[i].classList.toggle('low', bit === '0');ton id="i2c-ack-steps-btn">Show Steps</button>
            signalBits.children[i].textContent = bit;         <button id="i2c-ack-reset-btn">Reset</button>
        }, i * 300);            </div>
    });

    setTimeout(() => highlightSteps(steps), signal.length * 300 + 500);        <!-- NEW: I2C Configuration Section -->
}-section">
ration</h2>
function animateParity(containers, steps) {
    resetAnimation(containers, steps);.
    const signalBits = containers[0];            </div>
    const signal = '101010101'; // Data (10101010) + Parity bit (1)>  <!-- Added element for initI2cConfigAnimation -->
ntrols">
    signal.split('').forEach((bit, i) => {</button>
        setTimeout(() => {
            signalBits.children[i].classList.add('active');
            signalBits.children[i].classList.toggle('high', bit === '1');
            signalBits.children[i].classList.toggle('low', bit === '0');
            signalBits.children[i].textContent = bit;
        }, i * 300);        <!-- NEW: Sine Wave Animation Section -->
    });
           <h2>Problem ?: Sine Wave Animation</h2>
    setTimeout(() => highlightSteps(steps), signal.length * 300 + 500);            <div id="sine-wave-container" style="border:1px solid #ccc; margin-bottom:10px;"></div>
}function animateBaudRate(containers, steps) {    resetAnimation(containers, steps);    const signalBits = containers[0];    const signal = '0101010101'; // Example UART frame    signal.split('').forEach((bit, i) => {        setTimeout(() => {            signalBits.children[i].classList.add('active');            signalBits.children[i].classList.toggle('high', bit === '1');            signalBits.children[i].classList.toggle('low', bit === '0');            signalBits.children[i].textContent = bit;        }, i * 300);    });    setTimeout(() => highlightSteps(steps), signal.length * 300 + 500);}function animateI2cConfig(containers, steps) {    // This would be a more complex animation showing I2C open-drain behavior    // For now, we'll just highlight the steps    setTimeout(() => highlightSteps(steps), 1000);}function animateI2cAck(containers, steps) {    resetAnimation(containers, steps);    const ackSignal = containers[0];    const nackSignal = containers[1];        const ackBits = '00100'; // SDA pulled low for ACK    const nackBits = '11111'; // SDA remains high for NACK    ackBits.split('').forEach((bit, i) => {        setTimeout(() => {            ackSignal.children[i].classList.add('active');            ackSignal.children[i].classList.toggle('high', bit === '1');            ackSignal.children[i].classList.toggle('low', bit === '0');            ackSignal.children[i].textContent = bit;        }, i * 300);    });    nackBits.split('').forEach((bit, i) => {        setTimeout(() => {            nackSignal.children[i].classList.add('active');            nackSignal.children[i].classList.toggle('high', bit === '1');            nackSignal.children[i].classList.toggle('low', bit === '0');            nackSignal.children[i].textContent = bit;        }, i * 300);    });    setTimeout(() => highlightSteps(steps), Math.max(ackBits.length, nackBits.length) * 300 + 500);}function animateParityError(containers, steps) {    resetAnimation(containers, steps);    const signalBits = containers[0];    const signal = '1010101000'; // Data (10101010) + Parity bit (0) - even parity when odd expected    signal.split('').forEach((bit, i) => {        setTimeout(() => {            signalBits.children[i].classList.add('active');            signalBits.children[i].classList.toggle('high', bit === '1');            signalBits.children[i].classList.toggle('low', bit === '0');            signalBits.children[i].textContent = bit;        }, i * 300);    });    setTimeout(() => highlightSteps(steps), signal.length * 300 + 500);}function animateI2cAddress(containers, steps) {    resetAnimation(containers, steps);    const signalBits = containers[0];    const signal = '01110100'; // Address bits (0111010) + R/W bit (0)    signal.split('').forEach((bit, i) => {        setTimeout(() => {            signalBits.children[i].classList.add('active');            signalBits.children[i].classList.toggle('high', bit === '1');            signalBits.children[i].classList.toggle('low', bit === '0');            signalBits.children[i].textContent = bit;        }, i * 300);    });
                <button id="sine-wave-animate-btn">Animate Sine Wave</button>
            </div>
        </div>    setTimeout(() => highlightSteps(steps), signal.length * 300 + 500);




</html></body>    </div>}

function initSineWaveAnimation() {
    const container = document.getElementById('sine-wave-container');
    if (!container) {
        console.error("Sine wave container not found!");
        return;
    }
    // Clear any old content
    container.innerHTML = '';
    const canvas = document.createElement('canvas');
    canvas.width = 600;
    canvas.height = 150;
    container.appendChild(canvas);
    
    animateSineWave(canvas, {
        animationDuration: 3000,
        amplitude: 50,
        frequency: 0.02,
        lineColor: '#29abe2',
        lineWidth: 2,
    });
}
